# [编译器](https://github.com/HuJJ-NB/gitblog/issues/13)

记录一下编译原理课大作业。

## 进度

目前只做了词法分析和语法分析，其中词法分析用了PCRE的库，语法分析采用递归下降的办法自顶向下实现。

## 词法分析

我写了几条正则，记录了一下原始字符串和读取的位置，每次都按顺序匹配正则规则，匹配成功就返回一个`token`，然后修改读取位置、行号等一系列需要维护的信息，这个还是很简单的。

后续希望的，主要就是去掉PCRE的依赖，所以还是要自己实现一下比较好，应该不麻烦。

## 语法分析

语法分析我用了带回溯的LL分析，用递归下降的办法，想过用LR但是这一部分上课没听，课件有点抽象，而且LL分析貌似在主流编译器中用得更多，我也不知道为啥。其实一开始也考虑了能不能用LL(1)，这样不用回溯，但是chuj说这样后续文法可读性变差了，语义分析也不好做，我觉得有点道理。

目前碰到的最大的问题是带回溯的算法不好定位出错，一个产生式如果匹配不成功，该不该报错，如果`E->A|B`，A匹配不成功，B成功了，A不该报错，AB都不成功，那具体该哪报错呢，E报错吗？可是算法最终递归和回溯之后，都是回到最顶层，难道最后只能输出一句开始符号不能成功匹配？递归时函数携带的信息太少了，以至于很难得到准确的出错位置。

兴许可以在语法分析树的单元里面保存这些信息，同样是LL分析，LL(1)能避免这样的问题肯定是有比没有回溯来干扰更本质的原因的，它没有回溯意味着，每一个产生式都携带了更精确的信息，也许分析这些信息，能找到问题的答案。

毕竟chuj研究了很多项目的源码，他说gcc也是用的递归下降，看样子递归下降是可以有办法精确定位错误位置的。

## 计划

最后就画个饼吧，一方面，很多定长的数据结构是不符合工业要求的，还是要多采用用更先进的方式，工作量也不大；然后，语义分析和后端的部分也要做做完吧，希望暑假能有动力。

- [ ] 生成LR(1)项目集
- [ ] 语义分析
- [ ] 中间代码生成
- [ ] 编译后端（暂定目标为生成risc-V IM64指令集的ELF）
- [ ] 更符合工业标准的代码

